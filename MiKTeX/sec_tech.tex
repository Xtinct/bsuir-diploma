\lstset{style=fsharpstyle}

\section{Используемые технологии}
\label{sec:practice:technology_used}

Выбор технологий является важным предварительным этапом разработки сложных информационных систем.
Платформа и язык программирования, на котором будет реализована система, заслуживает большого внимания, так как исследования показали, что выбор языка программирования влияет на производительность труда программистов и качество создаваемого ими кода.

Ниже перечислены некоторые факторы, повлиявшие на выбор технологий:
\begin{itemize}
\item разрабатываемое ПО должно иметь возможность запускаться под платформами Windows(7,8,10) и Linux(Ubuntu, Arch Linux, Linux Mint);
\item ПО работает в совокупности с другими средствами описания аппарутры интегральных схем и должно иметь возможность запускаться в форме скрипта;
\item среди различных платформ разработки имеющийся программист лучше всего знаком с разработкой на платформе;
\item дальнейшей поддержкой проекта, возможно, будут заниматься разработчики, не принимавшие участие в выпуске первой версии;
\item имеющийся разработчик имеет опыт работы с объекто-ориентированными языками программирования;
\end{itemize}

Основываясь на опыте работы имеющихся программистов разрабатывать ПО целесообразно с помощью языка Ruby.
Приняв во внимание необходимость обеспечения доступности дальнейшей поддержки ПО, возможно, другой командой программистов, необходимость работы с различными ОС, скриптообразный характер ПО, целесообразно не использовать малоизвестные и сложные языки программирования.
С учетом этого фактора выбор языков программирования сужается до четырех: Perl, Python, Ruby и Lua.
Слабые по сравнению с другими языками механизмы ООП (отсутствие наследования, классов) языка LUA, которые могут быть полезны при разработке ПО, позволяют исключить этот язык из списка кандидатов.
Per уступает по удобству использования двум другим кандидатам из нашего списка.
Оставшиеся два языка программирования Ruby и Python являются первостепенным, мультипарадигменными языками программирования. Однако наличие синтаксического анализатора языка VHDL делает
Ruby предпочтительным кандидатом.
Таким образом, с учетом вышеперечисленных факторов, целесообразно остановить выбор на следующих технологиях:
\begin{itemize}
  \item операционные системы: семейство Windows(7,8,10), семейство Linux(Ubuntu, Debian, Arch Linux), Mac os;
  \item язык описания аппаратуры интегральных схем VHDL;
  \item язык программирования Ruby;
\end{itemize}
Для реализации поставленной задачи предпочительно использовать библиотеку синтаксического анализа языка HDL, помимо этого достаточно использовать стандартные библиотеки указанного выше языка.
Высокий уровень абстракции языка, полноценные механизмы ООП, динамическая система типов позволяют наиболее просто и <<красиво>> позволяет решить возникающую задачу.
Разрабатываемое программное обеспечение в некоторой степени использует данное преимущество языка.
Язык ruby будет использован для создания высокоуровнего дизайна проложения (иерархия классов и интерфейсов, организация модулей и публичного программного интерфейса), реализации логики приложения, функций и методов~\cite{dpir_2007}, прототипирования различных идей.
В разрабатываемом программном продукте Ruby используется для cинтаксического анализа, обработки полученной информации, трансформации исходного кода языка VHDL.


\subsection{Язык программирования Ruby}
\label{sub:practice:ruby_overview}
Ruby -- объектно-ориентированный, динамический язык программирования общего назначения~\cite{ruby_site}.
Язык разрабатывался с целью сделать <<настоящий объектно-ориентированный>>, лёгкий в разработке, интерпретируемый язык программирования.
Для достижения этой цели в языке гармонично сочетаются простота, выразительность.
Создателем языка с первой версии является  Юкихиро Мацумото (Matz).
Язык ruby является платформенно нейтральным, но создавался для хорошей работы с unix-подобными системами.
Этот язык сочетает простой синтаксис, похожий на синтаксис языков Perl и Python, и полную поддержку всех современных объектно-ориентированных концепций и подходов. В качестве ориентира при разработке языка была выбрана динамичность, нацеленная на написание простого и продуктивного кода~\cite{trpr_2011_ru}.

Язык имеет богатую поддержку парадигмы объекто-ориентированного программирования, включающую поддержку инкапсуляции, наследования и полиморфизма.
Отличительными чертами Ruby с точки зрения ОО парадигмы являются:
\begin{itemize}
  \item Динамическая система типов.
        В ruby реализована неявная(утиная) типизация: границы использования объекта определяются его текущим набором методов и свойств, в противоположность наследованию от определённого класса. Это значит, что объект реализует интерфейс, если он содержит все методы этого интерфейса, независимо от связей в иерархии наследования и принадлежности к какому-либо конкретному классу.
        В ruby все типы являются объектами, унаследованными от класса Object.
  \item Классы и интерфейсы.
        В классической объекто-ориентированной парадигме существуют только классы.
        В ruby дополнительно существуют и другие типы, например, модули.
        Модули в ruby похожи на классы в том, что они содержат набор методов, константы, другие модули и определения классов.
        Есть два предназначения модулей. Во-первых, они служат централизованного хранения констант и методов:
        \begin{lstlisting}[language=Ruby, style=rubystyle]
  module Trig
    PI = 3.1416
    # class methods
    def Trig.sin(x)
      # ...
    end
    def Trig.cos(x)
      # ...
    end
  end
        \end{lstlisting}

        Во-вторых, модули позволяют делить функциональность между классами, при включении (include) модуля в класс, его методы добавляются в класс. Такой способ называется примесью (mixin):

        \begin{lstlisting}[language=Ruby, style=rubystyle]
  module MyModule
    GOODMOOD = "happy"
    BADMOOD = "grumpy"

    def greet
      return "I'm #{GOODMOOD}. How are you?"
    end

    def MyModule.greet
      return "I'm #{BADMOOD}. How are you?"
    end
  end

  class MyClass
     include MyModule

    def sayHi
      puts( greet )
    end
  end

  ob = MyClass.new
  ob.sayHi
  puts(ob.greet)
        \end{lstlisting}
        <<Примеси>> могут быть использованы при необходимости проведения множественного наследования (в отличие от языков \cpp{} и Eiffel, ruby не поддерживает множественное наследование классов).
  \item Свойства и методы.
        В чистой объекто-ориентированной парадигме все функции являются методами.
        Свойство -- это такая разновидность функций, которая инкапсулирует часть состояния объекта.
        Cвойства в ruby являются обычными методами:
        \begin{lstlisting}[language=Ruby, style=rubystyle]
  class Song
    def duration
      @duration
    end
    def duration=(value)
      @duration = value
    end
  end
         \end{lstlisting}
         Однако простое обращение к внутренней переменной объекта может быть заменено на вызов метода attr\_accessor:
         \begin{lstlisting}[language=Ruby, style=rubystyle]
  class Song
    attr_accessor :duration
  end
         \end{lstlisting}
        По аналогии с другими языками, с помощью этих методов можно установить правила доступа к свойства: \cite{trpr_2011_ru}
        \begin{itemize}
        \item attr\_reader создаёт геттер для свойства;
        \item attr\_writer создаёт сеттер для свойства;
        \item attr\_accessor создаёт геттер и сеттер для свойства;
        \end{itemize}
\end{itemize}

Поскольку ruby является динамически типизированным языком, интерпретатор не осуществляет контроль за переменными, программист должен знать, c какими типами он работает.
Например, интерпретатор ruby может выполнить код который обращается со строками, как если бы они были целыми числами, но при этом велика вероятность получить runtime error.
Говоря более точно, интерпретатор ruby просто выполняет код, ответственность за соблюдение контракта ложится на программиста.
Динамическая типизация может стать причиной широкого круга ошибок, возникающих из-за ошибок типов.
Однако она делает написание и изменение программ более простым и понятным, кроме того, позволяет делать архитектуру приложения более гибкой.
Еще одним аспектом типизации в ruby является её строгость.
Строгая типизация означает, что язык не позволяет смешивать в выражениях различные типы и не выполняет автоматические неявные преобразования.
Например, нельзя вычесть из строки множество. Такие требования спасают от некоторых ошибок.

Ruby полагается на автоматическое управление памятью со стороны исполняющей среды, предоставляя совсем немного средств для управления жизненным циклом объектов.
Не смотря на это, в языке все же присутствуют указатели на функции.

Создатели языка ruby не являются противниками привнесения в язык новых идей и возможностей.
Каждая новая версия интерпретатора языка привносит различные полезные возможности, которые отвечают требованиям индустрии.


\subsection{Язык описания аппаратуры интегральных схем VHDL}
\label{sub:practice:vhdl_overview}
VHDL является формальной записью, предназначенной для описания функций и логической организации цифровой системы. Функция системы определяется как преобразование значений на входах в значения на выходах. Причем время в этом преобразовании задается явно. Организация системы задается перечнем связанных компонентов.

Объект проекта (entity) представляет собой описание компонента проекта, имеющего четко заданные входы и выходы и выполняющей четко определенную функцию \cite{vhdl_entity}. Объект проекта может представлять всю проектируемую систему, некоторую подсистему, устройство, узел, стойку, плату, кристалл, макроячейку, логический элемент и т.п.

В описании объекта проекта можно использовать компоненты, которые, в свою очередь, могут быть описаны как самостоятельные объекты проекта более низкого уровня. Таким образом, каждый компонент объекта проекта может быть связан с объектом проекта более низкого уровня. В результате такой декомпозиции объекта проекта пользователь строит иерархию объектов проекта, представляющих весь проект в целом и состоящую из нескольких уровней абстракций. Такая совокупность объектов проекта называется иерархией проекта (design hierarchy).Каждый объект проекта состоит, как минимум, из двух различных типов описаний: описания интерфейса и одного или более архитектурных тел.Интерфейс описывается в объявлении объекта проекта  (entity declaration)  и определяет только входы и выходы объекта проекта. Для описания поведения объекта или его структуры служит архитектурное тело (architecture body). Чтобы задать, какие объекты проекта использованы для создания полного проекта, используется объявление конфигурации (configuration declaration).

В языке VHDL  предусмотрен механизм пакетов для часто используемых описаний, констант, типов, сигналов \cite{vhdl_packages}. Эти описания помещаются в объявлении пакета (package declaration).Если пользователь использует нестандартные операции или функции, их интерфейсы описываются в объявлении пакета, а тела содержатся в теле пакета (package body).

Таким образом, при описании цифровой системы на языке VHDL,  пользователь может использовать пять различных типов описаний: объявление объекта проекта, архитектурное тело, объявление конфигурации, объявление пакета и тело пакета. Каждое из описаний является самостоятельной конструкцией языка  VHDL, может быть независимо проанализировано анализатором и поэтому получило название "Модуль проекта" (design unit).

Модули проекта, в свою очередь, можно разбить на две категории: первичные и вторичные. К первичным модулям относятся различного типа объявления. Ко вторичным  -  отдельно анализируемые тела первичных модулей. Один или несколько модулей проекта могут быть помещены в один файл, называемый файлом проекта (design file). Каждый проанализированный модуль проекта помещается в библиотеку проекта (design ibrary) и становится библиотечным модулем (library unit). Данная реализация позволяет создать любое число библиотек проекта. Каждая библиотека проекта в языке  VHDL имеет логическое имя (идентификатор). Фактическое имя файла, содержащего эту библиотеку, может совпадать или не совпадать с логическим именем библиотеки проекта. Для ассоциации логического имени библиотеки с соответствующим ей фактическим именем предусмотрен специальный механизм установки внешних ссылок.

По отношению к сеансу работы  VHDL существует два класса библиотек проекта: рабочие библиотеки и библиотеки ресурсов.Рабочая библиотека  -  это библиотека, с которой в данном сеансе работает пользователь и в которую помещается библиотечный модуль, полученный в результате анализа модуля проекта. Библиотека ресурсов  -  это библиотека, содержащая библиотечные модули, ссылка на которые имеется в анализируемом модуле проекта. В каждый конкретный момент пользователь работает с одной рабочей библиотекой и произвольным числом библиотек ресурсов.

Возможность создания и использования многих библиотек ресурсов позволяет пользователю классифицировать библиотечные модули по различным признакам. Например, в одной библиотеке хранить описания микросхем одной серии, в другой  -  описания микросхем другой серии и т.д.    Или водной библиотеке хранить описания микросхемс одним типом задержки,  в другой  -  описания микросхем с другим типом задержки и т.д.
