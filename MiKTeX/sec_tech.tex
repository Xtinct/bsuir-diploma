\lstset{style=fsharpstyle}

\section{Используемые технологии}
\label{sec:practice:technology_used}

Выбор технологий является важным предварительным этапом разработки сложных информационных систем.
Платформа и язык программирования, на котором будет реализована система, заслуживает большого внимания, так как исследования показали, что выбор языка программирования влияет на производительность труда программистов и качество создаваемого ими кода.

Ниже перечислены некоторые факторы, повлиявшие на выбор технологий:
\begin{itemize}
\item Разрабатываемое ПО должно иметь возможность запускаться под платформами Windows(7,8,10) и Linux(Ubuntu, Arch Linux, Linux Mint)
\item По работает в совокупности с другими средствами описания аппарутры интегральных схем и должно иметь возможность запускаться в форме скрипта.
\item Среди различных платформ разработки имеющийся программист лучше всего знаком с разработкой на платформе.
\item Дальнейшей поддержкой проекта, возможно, будут заниматься разработчики, не принимавшие участие в выпуске первой версии.
\item Имеющийся разработчик имеет опыт работы с объекто"=ориентированными языками программирования.
\end{itemize}

Основываясь на опыте работы имеющихся программистов разрабатывать ПО целесообразно с помощью языка Ruby.
Приняв во внимание необходимость обеспечения доступности дальнейшей поддержки ПО, возможно, другой командой программистов, необходимость работы с различными ОС, скриптообразный характер ПО, целесообразно не использовать малоизвестные и сложные языки программирования.
С учетом этого фактора выбор языков программирования сужается до четырех: Perl, Python, Ruby и Lua.
Слабые по сравнению с другими языками механизмы ООП\\(отсутствие наследования, классов) языка LUA, которые могут быть полезны при разработке ПО, позволяют исключить этот язык из списка кандидатов.
Per уступает по удобству использования двум другим кандидатам из нашего списка.
Оставшиеся два языка программирования Ruby и Python являются первостепенным, мультипарадигменными языками программирования. Однако наличие синтаксического анализатора языка VHDL делает
Ruby предпочтительным кандидатом.
Таким образом, с учетом вышеперечисленных факторов, целесообразно остановить выбор на следующих технологиях:
\begin{itemize}
  \item операционные системы: семейство Windows(7,8,10), семейство Linux\\(Ubuntu, Debian, Arch Linux);
  \item язык описания аппаратуры интегральных схем VHDL;
  \item язык программирования Ruby.
\end{itemize}
Для реализации поставленной задачи предпочительно использовать библиотеку синтаксического анализа языка HDL, помимо этого достаточно использовать стандартные библиотеки указанного выше языка.
Высокий уровень абстракции языка, полноценные механизмы ООП, динамическая система типов позволяют наиболее просто и <<красиво>> позволяет решить возникающую задачу.
Разрабатываемое программное обеспечение в некоторой степени использует данное преимущество языка.
Язык ruby будет использован для создания высокоуровнего дизайна проложения (иерархия классов и интерфейсов, организация модулей и публичного программного интерфейса), реализации логики приложения, функций и методов~\cite{dpir_2007}, прототипирования различных идей.
В разрабатываемом программном продукте Ruby используется для cинтаксического анализа, обработки полученной информации, трансформации исходного кода языка VHDL.
Далее проводится характеристика используемых технологий и языков программирования более подробно.


\subsection{Язык программирования Ruby}
\label{sub:practice:ruby_overview}
Ruby "--- объектно"=ориентированный, данимический язык программирования общего назначения.
Язык разрабатывался с целью сделать <<настоящий объектно-ориентированный>>, лёгкий в разработке, интерпретируемый язык программирования/
Для достижения этой цели в языке гармонично сочетаются простота, выразительность.
Создателем языка с первой версии является  Юкихиро Мацумото (Matz).
Язык ruby является платформенно нейтральным, но создавался для хорошей работы с unix-подобными системами.
Этот язык сочетает простой синтаксис, похожий на синтаксис языков Perl и Python, и полную поддержку всех современных объектно-ориентированных концепций и подходов. В качестве ориентира при разработке языка была выбрана динамичность, нацеленная на написание простого и продуктивного кода~\cite{trpr_2011_ru}.

Язык имеет богатую поддержку парадигмы объекто"=ориентированного программирования, включающую поддержку инкапсуляции, наследования и полиморфизма.
Отличительными чертами Ruby с точки зрения ОО парадигмы являются:
\begin{itemize}
  \item Динамическая система типов.
        В ruby реализована неявная(утиная) типизация: границы использования объекта определяются его текущим набором методов и свойств, в противоположность наследованию от определённого класса. Это значит, что объект реализует интерфейс, если он содержит все методы этого интерфейса, независимо от связей в иерархии наследования и принадлежности к какому-либо конкретному классу.
        В ruby все типы являются объектами, унаследованными от класса Object.
  \item Классы и интерфейсы.
        В классической объекто"=ориентированной парадигме существуют только классы.
        В ruby дополнительно существуют и другие типы, например, модули.
        Модули в ruby похожи на классы в том, что они содержат набор методов, константы, другие модули и определения классов.
        Есть два предназначения модулей. Во-первых, они служат централизованного хранения констант и методов:
        \begin{lstlisting}[language=Ruby, style=rubystyle]
  module Trig
    PI = 3.1416
    # class methods
    def Trig.sin(x)
      # ...
    end
    def Trig.cos(x)
      # ...
    end
  end
        \end{lstlisting}

        Во-вторых, модули позволяют делить функциональность между классами, при включении (include) модуля в класс, его методы добавляются в класс. Такой способ называется примесью (mixin):

        \begin{lstlisting}[language=Ruby, style=rubystyle]
  module MyModule
    GOODMOOD = "happy"
    BADMOOD = "grumpy"

    def greet
      return "I'm #{GOODMOOD}. How are you?"
    end

    def MyModule.greet
      return "I'm #{BADMOOD}. How are you?"
    end
  end

  class MyClass
     include MyModule

    def sayHi
      puts( greet )
    end
  end

  ob = MyClass.new
  ob.sayHi
  puts(ob.greet)
        \end{lstlisting}
        <<Примеси>> могут быть использованы при необходимости проведения множественного наследования (в отличие от языков \cpp{} и Eiffel, ruby не поддерживает множественное наследование классов).
  \item Свойства и методы.
        В чистой объекто"=ориентированной парадигме все функции являются методами.
        Свойство "--- это такая разновидность функций, которая инкапсулирует часть состояния объекта.
        Cвойства в ruby являются обычными методами:
        \begin{lstlisting}[language=Ruby, style=rubystyle]
  class Song
    def duration
      @duration
    end
    def duration=(value)
      @duration = value
    end
  end
         \end{lstlisting}
         Однако простое обращение к внутренней переменной объекта может быть заменено на вызов метода attr\_accessor:
         \begin{lstlisting}[language=Ruby, style=rubystyle]
  class Song
    attr_accessor :duration
  end
         \end{lstlisting}
        По аналогии с другими языками, с помощью этих методов можно установить правила доступа к свойства:\cite{trpr_2011_ru}
        \begin{itemize}
        \item attr\_reader создаёт геттер для свойства
        \item attr\_writer создаёт сеттер для свойства
        \item attr\_accessor создаёт геттер и сеттер для свойства
        \end{itemize}
\end{itemize}

Поскольку ruby является динамически типизированным языком, интерпретатор не осуществляет контроль за переменными, программист должен знать, c какими типами он работает.
Например, интерпретатор ruby может выполнить код который обращается со строками, как если бы они были целыми числами, но при этом велика вероятность получить runtime error.
Говоря более точно, интерпретатор ruby просто выполняет код, ответственность за соблюдение контракта ложится на программиста.
Динамическая типизация может стать причиной широкого круга ошибок, возникающих из-за ошибок типов.
Однако она делает написание и изменение программ более простым и понятным, кроме того, позволяет делать архитектуру приложения более гибкой.
Еще одним аспектом типизации в ruby является её строгость.
Строгая типизация означает, что язык не позволяет смешивать в выражениях различные типы и не выполняет автоматические неявные преобразования.
Например, нельзя вычесть из строки множество/
Такие требования спасают от некоторых ошибок.

Ruby полагается на автоматическое управление памятью со стороны исполняющей среды, предоставляя совсем немного средств для управления жизненным циклом объектов.
Не смотря на это, в языке все же присутствуют указатели на функции.

Как уже упоминалось, ruby не является платформенно зависимым языком.
Интерпретаторы существуют для всех основным операционных систем(хотя некоторые из них поддерживаются лучше остальных).


Создатели языка ruby не являются противниками привнесения в язык новых идей и возможностей.
Каждая новая версия интерпретатора языка привносит различные полезные возможности, которые отвечают требованиям индустрии.


% Первая версия \csharp{} была похожа по своим возможностям на \java{} 1.4, несколько их расширяя: так, в \csharp{} имелись свойства (выглядящие в коде как поля объекта, но на деле вызывающие при обращении к ним методы класса), индексаторы (подобные свойствам, но принимающие параметр как индекс массива), события, делегаты, циклы \lstinline!foreach!, структуры, передаваемые по значению, автоматическое преобразование встроенных типов в объекты при необходимости (boxing), атрибуты, встроенные средства взаимодействия с неуправляемым кодом (DLL, COM) и прочее~\cite{csharp_wiki_2013_ru}.

% Версия \dotnet{} 2.0 привнесла много новых возможностей в сравнении с предыдущей версией, что отразилось и на языках под эту платформу.
% Проект спецификации \csharp{} 2.0 впервые был опубликован Microsoft в октябре 2003 года; в 2004 году выходили бета"=версии (проект с кодовым названием Whidbey), \csharp{} 2.0 окончательно вышел 7 ноября 2005 года вместе с Visual Studio 2005 и \dotnet{} 2.0.
% Ниже перечислены новые возможности в версии 2.0
% \begin{itemize}
%   \item Частичные типы (разделение реализации класса более чем на один файл).

%   \item Обобщённые, или параметризованные типы (generics).
%   В отличие от шаблонов \cpp{}, они поддерживают некоторые дополнительные возможности и работают на уровне виртуальной машины.
%   Вместе с тем, параметрами обобщённого типа не могут быть выражения, они не могут быть полностью или частично специализированы, не поддерживают шаблонных параметров по умолчанию, от шаблонного параметра нельзя наследоваться.

%   \item Новая форма итератора, позволяющая создавать сопрограммы с помощью ключевого слова \lstinline[style=csharpinlinestyle]!yield!, подобно Python и Ruby.

%   \item Анонимные методы, обеспечивающие функциональность замыканий.

%   \item Оператор ??: \lstinline!return obj1 ?? obj2;! означает (в нотации \csharp{} 1.0) \lstinline[style=csharpinlinestyle]/return obj1!=null ? obj1 : obj2;/.

%   \item Обнуляемые (nullable) типы"=значения (обозначаемые вопросительным знаком, например, \lstinline[style=csharpinlinestyle]!int? i = null;!), представляющие собой те же самые типы-значения, способные принимать также значение null.
%   Такие типы позволяют улучшить взаимодействие с базами данных через язык SQL.

%   \item Поддержка 64-разрядных вычислений позволяет увеличить адресное пространство и использовать 64-разрядные примитивные типы данных~\cite{csharp_wiki_2013_ru}.
% \end{itemize}

% Третья версия языка имела одно большое нововведение "--- Language Integrated Query (LINQ), для реализации которого в языке дополнительно появилось множество дополнительных возможностей.
% Ниже приведены некоторые из них:
% \begin{itemize}
%   \item Ключевые слова \lstinline[style=csharpinlinestyle]!select!, \lstinline[style=csharpinlinestyle]!from!, \lstinline[style=csharpinlinestyle]!where!, позволяющие делать запросы из SQL, XML, коллекций и т.\,п.

%   \item Инициализацию объекта вместе с его свойствами:
%   \begin{lstlisting}[style=csharpinlinestyle]
% Customer c = new Customer(); c.Name = "James"; c.Age=30;
%   \end{lstlisting}
%   можно записать как
%   \begin{lstlisting}[style=csharpinlinestyle]
% Customer c = new Customer { Name = "James", Age = 30 };
%   \end{lstlisting}

%   \item Лямбда-выражения:
%   \begin{lstlisting}[style=csharpinlinestyle]
% listOfFoo.Where(delegate(Foo x) { return x.size > 10; });
%   \end{lstlisting}
%   теперь можно записать как
%   \begin{lstlisting}[style=csharpinlinestyle]
% listOfFoo.Where(x => x.size > 10);
%   \end{lstlisting}

%   \item Деревья выражений "--- лямбда-выражения теперь могут быть представлены в виде структуры данных, доступной для обхода во время выполнения, тем самым позволяя транслировать строго типизированные \csharp{}-выражения в другие домены (например, выражения SQL).

%   \item Вывод типов локальной переменной: \lstinline[style=csharpinlinestyle]!var x = "hello";! вместо \lstinline[style=csharpinlinestyle]!string x = "hello";!

%   \item Безымянные типы: \lstinline[style=csharpinlinestyle]!var x = new { Name = "James" };!

%   \item Методы-расширения "--- добавление метода в существующий класс с помощью ключевого слова \lstinline[style=csharpinlinestyle]!this! при первом параметре статической функции.

%   \item Автоматические свойства: компилятор сгенерирует закрытое  поле и соответствующие аксессор и мутатор для кода вида
%   \begin{lstlisting}[style=csharpinlinestyle]
% public string Name { get; private set; }
%   \end{lstlisting}

% \end{itemize}
% \csharp{} 3.0 совместим с \csharp{} 2.0 по генерируемому MSIL-коду; улучшения в языке "--- чисто синтаксические и реализуются на этапе компиляции~\cite{csharp_wiki_2013_ru}.

% \vbnet{} 10.0 и \csharp{} 4.0 были выпущены в апреле 2010 года, одновременно с выпуском Visual Studio 2010.
% Новые возможности в версии 4.0:
% \begin{itemize}
%   \item Возможность использования позднего связывания.
%   \item Именованные и опциональные параметры.
%   \item Новые возможности COM interop.
%   \item Ковариантность и контрвариантность интерфейсов и делегатов.
%   \item Контракты в коде (Code Contracts)~\cite{csharp_wiki_2013_ru}.
% \end{itemize}

% В \csharp{} 5.0 было немного нововведений, но они носят большую практическую ценность.
% В новой версии появилась упрощенная поддержка выполнения асинхронных функций с помощью двух новых слов "---  \lstinline[style=csharpinlinestyle]!async! и \lstinline[style=csharpinlinestyle]!await!.
% Ключевым словом \lstinline[style=csharpinlinestyle]!async! помечаются методы и лямбда"=выражения, которые внутри содержат ожидание выполнения асинхронных операций с помощью оператора \lstinline[style=csharpinlinestyle]!await!, который отвечает за преобразования кода метода во время компиляции.



\subsection{Язык описания аппаратуры интегральных схем VHDL}
\label{sub:practice:vhdl_overview}
VHDL является формальной записью, предназначенной для описания функций и логической организации цифровой системы. Функция системы определяется как преобразование значений на входах в значения на выходах. Причем время в этом преобразовании задается явно. Организация системы задается перечнем связанных компонентов.

Объект проекта (entity) представляет собой описание компонента проекта, имеющего четко заданные входы и выходы и выполняющей четко определенную функцию. Объект проекта может представлять всю проектируемую систему, некоторую подсистему, устройство, узел, стойку, плату, кристалл, макроячейку, логический элемент и т.п.

В описании объекта проекта можно использовать компоненты, которые, в свою очередь, могут быть описаны как самостоятельные объекты проекта более низкого уровня. Таким образом, каждый компонент объекта проекта может быть связан с объектом проекта более низкого уровня. В результате такой декомпозиции объекта проекта пользователь строит иерархию объектов проекта, представляющих весь проект в целом и состоящую из нескольких уровней абстракций. Такая совокупность объектов проекта называется иерархией проекта (design hierarchy).Каждый объект проекта состоит, как минимум, из двух различных типов описаний: описания интерфейса и одного или более архитектурных тел.Интерфейс описывается в объявлении объекта проекта  (entity declaration)  и определяет только входы и выходы объекта проекта. Для описания поведения объекта или его структуры служит архитектурное тело (architecture body). Чтобы задать, какие объекты проекта использованы для создания полного проекта, используется объявление конфигурации (configuration declaration).

В языке VHDL  предусмотрен механизм пакетов для часто используемых описаний, констант, типов, сигналов. Эти описания помещаются в объявлении пакета (package declaration).Если пользователь использует нестандартные операции или функции, их интерфейсы описываются в объявлении пакета, а тела содержатся в теле пакета (package body).

Таким образом, при описании цифровой системы на языке VHDL,  пользователь может использовать пять различных типов описаний: объявление объекта проекта, архитектурное тело, объявление конфигурации, объявление пакета и тело пакета. Каждое из описаний является самостоятельной конструкцией языка  VHDL, может быть независимо проанализировано анализатором и поэтому получило название "Модуль проекта" (designunit).

Модули проекта, в свою очередь, можно разбить на две категории: первичные и вторичные. К первичным модулям относятся различного типа объявления. Ко вторичным  -  отдельно анализируемые тела первичных модулей. Один или несколько модулей проекта могут быть помещены в один файл, называемый файлом проекта (design file). Каждый проанализированный модуль проекта помещается в библиотеку проекта (design ibrary) и становится библиотечным модулем (library unit). Данная реализация позволяет создать любое число библиотек проекта. Каждая библиотека проекта в языке  VHDL имеет логическое имя (идентификатор). Фактическое имя файла, содержащего эту библиотеку, может совпадать или не совпадать с логическим именем библиотеки проекта. Для ассоциации логического имени библиотеки с соответствующим ей фактическим именем предусмотрен специальный механизм установки внешних ссылок.

По отношению к сеансу работы  VHDL существует два класса библиотек проекта: рабочие библиотеки и библиотеки ресурсов.Рабочая библиотека  -  это библиотека, с которой в данном сеансе работает пользователь и в которую помещается библиотечный модуль, полученный в результате анализа модуля проекта. Библиотека ресурсов  -  это библиотека, содержащая библиотечные модули, ссылка на которые имеется в анализируемом модуле проекта. В каждый конкретный момент пользователь работает с одной рабочей библиотекой и произвольным числом библиотек ресурсов.

Возможность создания и использования многих библиотек ресурсов позволяет пользователю классифицировать библиотечные модули по различным признакам. Например, в одной библиотеке хранить описания микросхем одной серии, в другой  -  описания микросхем другой серии и т.д.    Или водной библиотеке хранить описания микросхемс одним типом задержки,  в другой  -  описания микросхем с другим типом задержки и т.д.
